<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GTA â€” Practice UI + GTA features</title>
<link rel="stylesheet" href="styles.css" />
</head>
<body>
<div class="container">
  <div class="header">
    <div class="brand">Practice â†’ GTA (Sunstrike)</div>
    <div class="nav">
      <a href="index.html">Dashboard</a>
      <a href="practice.html">Practice</a>
      <a href="gta.html" class="active">GTA</a>
      <a href="calc.html">Calculations</a>
      <a href="progress.html">Progress</a>
      <a href="tests.html">Tests</a>
    </div>
  </div>

  <main>
    <div class="card">
      <div class="h1">GTA Session (Practice UI)</div>
      <div class="small">Static main timer â€” time is consumed only when a question is successfully submitted. Use Pause if you step away. You must mark result after submitting.</div>

      <div style="margin-top:12px" class="row">
        <div style="flex:1">
          <label class="small">Session Name</label>
          <input id="gta-session" class="input" placeholder="GTA_2025-12-06_001">
        </div>
        <div style="width:160px">
          <label class="small">Total Time (min)</label>
          <select id="gta-total" class="input">
            <option>180</option><option>120</option><option>90</option><option>60</option>
          </select>
        </div>
        <div style="width:160px">
          <label class="small">Subject</label>
          <select id="gta-sub" class="input"><option>Mixed</option><option>Maths</option><option>Physics</option><option>Chemistry</option></select>
        </div>
        <div style="width:160px">
          <label class="small">Difficulty</label>
          <select id="gta-diff" class="input"><option>Mixed</option><option>Easy</option><option>Medium</option><option>Hard</option><option>Insane</option></select>
        </div>
      </div>

      <div style="margin-top:12px" class="row">
        <button id="gta-start" class="btn">Start GTA</button>
        <button id="gta-end" class="btn ghost">End Session</button>
        <button id="gta-export" class="btn">Export</button>
        <button id="gta-clear-session" class="btn ghost">Clear Session Logs</button>
      </div>

      <div style="margin-top:14px" class="row">
        <div style="flex:1" class="card">
          <div class="small">Main time left</div>
          <div class="h1" id="main-time">03:00:00</div>
        </div>
        <div style="width:180px" class="card">
          <div class="small">Question #</div>
          <div class="h1" id="q-number">â€”</div>
        </div>
        <div style="width:220px" class="card">
          <div class="small">Question timer</div>
          <div class="h1" id="q-timer">00:00.0</div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="q-start" class="btn">Start</button>
            <button id="q-pause" class="btn ghost" disabled>Pause</button>
            <button id="q-resume" class="btn ghost" disabled>Resume</button>
            <button id="q-submit" class="btn" disabled>Submit</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="h1">Session Logs (this GTA)</div>
      <div class="small">Select exactly two logs to enable Merge. After Submit, mark Correct / Incorrect / Unattempted using the three buttons.</div>
      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="merge" class="btn ghost" disabled>Merge Selected (2)</button>
        <button id="undo-merge" class="btn ghost" disabled>Undo Merge</button>
      </div>
      <div id="gta-log-list" class="list small" style="margin-top:12px; max-height:420px; overflow:auto"></div>
    </div>
  </main>
</div>

<footer>Sunstrike â€” GTA (Practice UI)</footer>

<!-- SheetJS for Excel export -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="utils.js"></script>
<script>
/* GTA implemented on top of Practice UI
   - static main timer (only reduced on successful submit)
   - per-question start / pause / resume / submit
   - submit -> saved pending log -> immediate 3-button result selection
   - reject if question time > remaining main time (session continues)
   - merge exactly two selected logs (merge time, result = 2nd selected), recalc XP
   - undo last merge
   - export session to XLSX
   - uses utils.js save/load/addXP functions
*/

(() => {
  // --- state
  let gtaRunning = false;
  let mainSeconds = 180*60; // dynamic when started
  let qNumber = 0;

  // question timer state
  let qState = 'idle'; // idle | running | paused
  let qStart = 0, qElapsed = 0, qInterval = null;

  // last merge undo
  let lastMerge = null;

  // shortcuts
  const el = id => document.getElementById(id);
  const PRACT = SU.KEYS.PRACTICE;

  // formatters
  function fmtMS(ms){
    const s = Math.floor(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    const t = Math.floor(ms%1000/100);
    return `${mm}:${ss}.${t}`;
  }
  function fmtMain(sec){
    if(sec < 0) sec = 0;
    const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = Math.floor(sec%60);
    return [String(h).padStart(2,'0'), String(m).padStart(2,'0'), String(s).padStart(2,'0')].join(':');
  }

  // points calc (same idea as practice)
  function calcPoints(timeSec, diff){
    const base = diff==='Easy'?8:diff==='Medium'?15:diff==='Hard'?40:diff==='Insane'?80:10;
    const pts = Math.max(0, Math.round(base - Math.floor(timeSec/4)));
    return Math.max(1, pts);
  }

  // UI updates
  function renderHeader(){
    el('main-time').textContent = fmtMain(mainSeconds);
    el('q-number').textContent = qNumber>0? qNumber : 'â€”';
    el('q-start').disabled = !gtaRunning || qState==='running';
    el('q-pause').disabled = qState !== 'running';
    el('q-resume').disabled = qState !== 'paused';
    // submit allowed only when running and not paused
    el('q-submit').disabled = !(qState === 'running');
  }

  // LOGS UI
  function renderLogs(){
    const sessionName = el('gta-session').value || localStorage.getItem('su_default_gta') || '';
    const root = el('gta-log-list');
    root.innerHTML = '';
    if(!sessionName) { root.innerHTML = '<div class="small">Set a session name and start.</div>'; disableMerge(); return; }
    const sessionKey = 'GTA:' + sessionName;
    const all = load(PRACT, []).filter(x => x.session === sessionKey).sort((a,b)=> (a.t||0)-(b.t||0));
    if(all.length === 0){ root.innerHTML = '<div class="small">No logs in this session yet.</div>'; disableMerge(); return; }

    all.forEach((log, idx) => {
      const wrap = document.createElement('div'); wrap.className = 'topic';
      // left: checkbox + info
      const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
      const cb = document.createElement('input'); cb.type = 'checkbox'; cb.className = 'merge-cb'; cb.dataset.t = log.t;
      cb.style.marginRight = '8px';
      left.appendChild(cb);
      const info = document.createElement('div');
      info.innerHTML = `<strong>Q${log.q || (idx+1)} â€¢ ${log.subject}${log.topic? ' â€¢ '+log.topic : ''}</strong><div class="small">${log.diff} â€¢ ${log.time}s â€¢ ${new Date(log.t).toLocaleString()}</div>`;
      left.appendChild(info);

      // right: result buttons + delete
      const right = document.createElement('div'); right.style.display='flex'; right.style.flexDirection='column'; right.style.alignItems='flex-end';
      const btnRow = document.createElement('div'); btnRow.style.display='flex'; btnRow.style.gap='8px';
      // result buttons (match practice style)
      const btnCorrect = document.createElement('button'); btnCorrect.className='btn'; btnCorrect.textContent='ðŸŸ©';
      const btnIncorrect = document.createElement('button'); btnIncorrect.className='btn'; btnIncorrect.textContent='âŒ';
      const btnUn = document.createElement('button'); btnUn.className='btn ghost'; btnUn.textContent='â—¯';
      // visually mark current selection
      function styleResultButtons(){
        btnCorrect.style.opacity = log.result==='Correct'? '1' : '0.6';
        btnIncorrect.style.opacity = log.result==='Incorrect'? '1' : '0.6';
        btnUn.style.opacity = (log.result==='Unattempted' || log.result==='Not Attempted')? '1' : '0.6';
      }
      styleResultButtons();

      btnCorrect.onclick = () => { updateLogResult(log.t, 'Correct'); };
      btnIncorrect.onclick = () => { updateLogResult(log.t, 'Incorrect'); };
      btnUn.onclick = () => { updateLogResult(log.t, 'Unattempted'); };

      btnRow.appendChild(btnCorrect); btnRow.appendChild(btnIncorrect); btnRow.appendChild(btnUn);

      const del = document.createElement('button'); del.className='btn ghost'; del.textContent='Delete';
      del.onclick = () => { if(!confirm('Delete this log?')) return; deleteLog(log.t); };

      right.appendChild(btnRow);
      right.appendChild(del);

      const container = document.createElement('div'); container.style.display='flex'; container.style.justifyContent='space-between'; container.style.alignItems='center';
      container.appendChild(left); container.appendChild(right);
      wrap.appendChild(container);
      root.appendChild(wrap);

      // keep visual in sync if user changes result externally
      // add listener to update style on render
    });

    // add listeners for merge checkboxes
    document.querySelectorAll('.merge-cb').forEach(cb => cb.addEventListener('change', onMergeSelectionChange));
    updateMergeButtons();
  }

  function updateMergeButtons(){
    const checks = Array.from(document.querySelectorAll('.merge-cb') || []).filter(c=> c.checked);
    el('merge').disabled = checks.length !== 2;
    el('undo-merge').disabled = !lastMerge;
  }
  function disableMerge(){ el('merge').disabled = true; el('undo-merge').disabled = !lastMerge; }

  function onMergeSelectionChange(){ updateMergeButtons(); }

  // storage helpers
  function saveEntry(e){
    const arr = load(PRACT, []);
    // dedupe by timestamp t
    if(arr.some(x => x.t === e.t)) return false;
    arr.push(e);
    save(PRACT, arr);
    return true;
  }
  function deleteLog(ts){
    let arr = load(PRACT, []);
    arr = arr.filter(x => x.t !== ts);
    save(PRACT, arr);
    renderLogs();
  }
  function updateLogResult(ts, newResult){
    const arr = load(PRACT, []);
    const i = arr.findIndex(x => x.t === ts);
    if(i === -1) return;
    const old = arr[i];
    arr[i] = Object.assign({}, old, { result: newResult });
    // handle XP effects: if marking incorrect, set points = 0
    if(newResult === 'Incorrect') arr[i].points = 0;
    save(PRACT, arr);
    renderLogs();
  }

  // start / pause / resume / submit question
  function qStartHandler(){
    if(!gtaRunning) { alert('Start GTA session first'); return; }
    if(qState === 'running') return;
    // start new question cycle
    qNumber += 1;
    qStart = Date.now() - qElapsed;
    qInterval = setInterval(()=> {
      qElapsed = Date.now() - qStart;
      el('q-timer').textContent = fmtMS(qElapsed);
    }, 100);
    qState = 'running';
    renderHeader();
  }
  function qPauseHandler(){
    if(qState !== 'running') return;
    clearInterval(qInterval); qInterval = null;
    qState = 'paused';
    renderHeader();
  }
  function qResumeHandler(){
    if(qState !== 'paused') return;
    qStart = Date.now() - qElapsed;
    qInterval = setInterval(()=> {
      qElapsed = Date.now() - qStart;
      el('q-timer').textContent = fmtMS(qElapsed);
    }, 100);
    qState = 'running';
    renderHeader();
  }
  function qResetStateAfterSubmit(){
    // clear timer & reset state so next question can start cleanly
    if(qInterval) clearInterval(qInterval);
    qInterval = null;
    qElapsed = 0;
    qState = 'idle';
    el('q-timer').textContent = '00:00.0';
    renderHeader();
  }

  function qSubmitHandler(){
    if(qState === 'paused'){ alert('Resume before submitting.'); return; }
    if(qState !== 'running'){ alert('Start the question before submitting.'); return; }
    // stop timer
    if(qInterval) { clearInterval(qInterval); qInterval = null; }
    const timeSec = Math.round((qElapsed||0)/1000);
    // check against mainSeconds
    if(timeSec > mainSeconds){
      alert('Time exceeded remaining main time â€” submission rejected. Session continues.');
      // reset question state for retry (do not reduce mainSeconds)
      qResetStateAfterSubmit();
      return;
    }
    // prepare entry (pending result)
    const name = el('gta-session').value || localStorage.getItem('su_default_gta') || ('GTA_'+new Date().toISOString().slice(0,10)+'_'+Math.floor(Math.random()*1000));
    el('gta-session').value = name;
    localStorage.setItem('su_default_gta', name);
    const sessionKey = 'GTA:'+name;
    const sub = el('gta-sub').value || 'Mixed';
    const diff = el('gta-diff').value || 'Mixed';
    const pts = calcPoints(timeSec, diff);
    const entry = { session: sessionKey, subject: sub, topic: '', diff, time: timeSec, points: pts, result: 'Pending', q: qNumber, t: Date.now() };
    const ok = saveEntry(entry);
    if(!ok){
      alert('Duplicate prevented (try again).');
      qResetStateAfterSubmit();
      return;
    }
    // reduce mainSeconds (static main timer updated only on save)
    mainSeconds -= timeSec;
    if(mainSeconds < 0) mainSeconds = 0;
    renderHeader();
    renderLogs();

    // immediate result UI (three big buttons) like Practice but inline modal-like:
    showResultSelector(entry.t);

    // reset question to allow next question
    qResetStateAfterSubmit();
  }

  // result UI (non-blocking) - place temporary overlay/panel near the top of logs
  function showResultSelector(ts){
    const sessionRoot = el('gta-log-list');
    // build a small floating panel
    const panel = document.createElement('div');
    panel.className = 'card';
    panel.style.position = 'sticky';
    panel.style.top = '8px';
    panel.style.zIndex = 40;
    panel.style.display = 'flex';
    panel.style.flexDirection = 'column';
    panel.style.gap = '8px';
    panel.innerHTML = `<div class="h1">Mark Result</div><div class="small">Choose result for the last submitted question</div>`;
    const btnRow = document.createElement('div'); btnRow.style.display='flex'; btnRow.style.gap='8px';
    const bC = document.createElement('button'); bC.className='btn'; bC.textContent='ðŸŸ© Correct';
    const bI = document.createElement('button'); bI.className='btn'; bI.textContent='âŒ Incorrect';
    const bU = document.createElement('button'); bU.className='btn ghost'; bU.textContent='â—¯ Unattempted';
    btnRow.appendChild(bC); btnRow.appendChild(bI); btnRow.appendChild(bU);
    panel.appendChild(btnRow);
    // insert panel at top
    sessionRoot.parentNode.insertBefore(panel, sessionRoot);

    function clearPanel(){
      if(panel && panel.parentNode) panel.parentNode.removeChild(panel);
      renderLogs();
      updateMergeButtons();
    }

    function applyResult(choice){
      const arr = load(PRACT, []);
      const i = arr.findIndex(x => x.t === ts);
      if(i === -1){ clearPanel(); return; }
      const entry = arr[i];
      if(choice === 'Correct'){ entry.result = 'Correct'; /* points already saved */ }
      else if(choice === 'Incorrect'){ entry.result = 'Incorrect'; entry.points = 0; }
      else { entry.result = 'Unattempted'; /* keep points so can merge later */ }
      arr[i] = entry;
      save(PRACT, arr);
      // award extra XP only if result is correct AND points > 0: but points were given at save time already.
      // If you want to give immediate XP for marking correct and previously 'pending' had not added XP, adapt here.
      clearPanel();
    }

    bC.onclick = ()=> applyResult('Correct');
    bI.onclick = ()=> applyResult('Incorrect');
    bU.onclick = ()=> applyResult('Unattempted');
  }

  // Merge exactly 2 selected logs
  function mergeHandler(){
    const checks = Array.from(document.querySelectorAll('.merge-cb') || []).filter(c=> c.checked);
    if(checks.length !== 2) return alert('Select exactly 2 logs to merge.');
    const t1 = Number(checks[0].dataset.t), t2 = Number(checks[1].dataset.t);
    const arr = load(PRACT, []);
    const l1 = arr.find(x=> x.t === t1), l2 = arr.find(x=> x.t === t2);
    if(!l1 || !l2) return alert('Selected logs not found.');
    // ensure same session
    if(l1.session !== l2.session){
      if(!confirm('Selected logs are from different sessions. Merge anyway?')) return;
    }
    // compute combined
    const combinedTime = (Number(l1.time)||0) + (Number(l2.time)||0);
    // result = result of second selected (order is checkbox order)
    const newResult = l2.result || 'Pending';
    const newDiff = l2.diff || l1.diff || 'Mixed';
    const newQ = Math.min(l1.q||9999, l2.q||9999);
    const newPoints = calcPoints(Math.round(combinedTime), newDiff);

    const newEntry = { session: l1.session, subject: l2.subject || l1.subject, topic: (l1.topic||'') + (l2.topic? ' + '+l2.topic : ''), diff: newDiff, time: Math.round(combinedTime), points: newPoints, result: newResult, q: newQ, t: Date.now() };

    // remove old and add new
    const remaining = arr.filter(x => x.t !== t1 && x.t !== t2);
    // store undo info
    lastMerge = { removed: [l1, l2], added: newEntry };
    remaining.push(newEntry);
    save(PRACT, remaining);

    // XP adjustment: previously points for l1 + l2 were already given at their saves.
    // As per decision, recalc XP based on combined time -> newPoints.
    // We add deltaXP = newPoints - (old1.points + old2.points) if positive; do not subtract negative (safer).
    const oldSum = (Number(l1.points)||0) + (Number(l2.points)||0);
    const delta = newPoints - oldSum;
    if(delta > 0) addXP(delta, 'merge'); // reward delta
    else {
      // do not subtract XP to prevent negative surprises; but inform user
      console.log('Merged reduced total points by', -delta, '- no XP subtraction applied.');
    }

    alert(`Merged logs â€” new time ${newEntry.time}s â€¢ result ${newEntry.result} â€¢ points ${newEntry.points}`);
    renderLogs();
    updateMergeButtons();
  }

  function undoMerge(){
    if(!lastMerge) return alert('No merge to undo.');
    const arr = load(PRACT, []);
    // remove added
    const remaining = arr.filter(x => x.t !== lastMerge.added.t);
    // put back removed
    remaining.push(...lastMerge.removed);
    save(PRACT, remaining);
    alert('Undo merge done (restored previous logs).');
    lastMerge = null;
    renderLogs();
    updateMergeButtons();
  }

  // export current session logs to excel
  function exportHandler(){
    const name = el('gta-session').value || localStorage.getItem('su_default_gta') || '';
    if(!name) return alert('Set session name first.');
    const session = 'GTA:'+name;
    const all = load(PRACT, []).filter(x=> x.session === session);
    if(!all.length) return alert('No logs to export.');
    const seen = {}; const unique = [];
    all.forEach(r => { if(!seen[r.t]){ seen[r.t]=true; unique.push(r); } });
    const ws = [['Date','Session','Q#','Subject','Topic','Difficulty','Time(s)','Result','Points']];
    unique.forEach(r => ws.push([ new Date(r.t).toLocaleString(), r.session, r.q||'', r.subject, r.topic||'', r.diff, r.time, r.result, r.points ]));
    const wb = XLSX.utils.book_new(); const ws1 = XLSX.utils.aoa_to_sheet(ws);
    XLSX.utils.book_append_sheet(wb, ws1, 'GTA'); XLSX.writeFile(wb, 'Sunstrike_GTA_'+name+'.xlsx');
  }

  // clear session logs
  function clearSession(){
    const name = el('gta-session').value || localStorage.getItem('su_default_gta') || '';
    if(!name) return alert('No session name set');
    if(!confirm('Clear ALL logs for this session?')) return;
    let arr = load(PRACT, []);
    arr = arr.filter(x => x.session !== ('GTA:'+name));
    save(PRACT, arr);
    renderLogs();
  }

  // start/stop GTA session
  el('gta-start').addEventListener('click', ()=>{
    if(gtaRunning) return alert('GTA already running');
    const tn = Number(el('gta-total').value||180);
    mainSeconds = tn*60;
    el('main-time').textContent = fmtMain(mainSeconds);
    // ensure session name
    el('gta-session').value = el('gta-session').value || ('GTA_'+new Date().toISOString().slice(0,10)+'_'+Math.floor(Math.random()*1000));
    localStorage.setItem('su_default_gta', el('gta-session').value);
    gtaRunning = true;
    qNumber = 0;
    qElapsed = 0;
    qState = 'idle';
    renderHeader();
    renderLogs();
    alert('GTA started ('+tn+' min). Main timer is static and deducts time only when you submit questions.');
  });
  el('gta-end').addEventListener('click', ()=>{
    if(!gtaRunning) return;
    if(!confirm('End GTA session now?')) return;
    gtaRunning = false;
    renderHeader();
  });

  // question controls
  el('q-start').addEventListener('click', qStartHandler);
  el('q-pause').addEventListener('click', qPauseHandler);
  el('q-resume').addEventListener('click', qResumeHandler);
  el('q-submit').addEventListener('click', qSubmitHandler);

  // merge/export/undo/clear
  el('merge').addEventListener('click', mergeHandler);
  el('undo-merge').addEventListener('click', undoMerge);
  el('gta-export').addEventListener('click', exportHandler);
  el('gta-clear-session').addEventListener('click', clearSession);

  // refresh UI when storage changes (multi-tab)
  window.addEventListener('storage', (e)=>{
    if(e.key === PRACT) renderLogs();
  });

  // initial render
  renderHeader();
  renderLogs();

})();
</script>
</body>
</html>