<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GTA â€” Practice UI (Final)</title>
<link rel="stylesheet" href="styles.css" />
<style>
/* Minimal, stable styling (no animations) */
.container{max-width:1100px;margin:16px auto;padding:14px}
.card{background:#071026;border-radius:10px;padding:12px;color:#eaf4ff;margin-top:12px;border:1px solid rgba(255,255,255,0.04)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.input, select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#eaf4ff;margin-top:6px}
.btn{padding:8px 10px;border-radius:8px;border:0;cursor:pointer;background:#7c3aed;color:#fff;font-weight:700}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dfeeff}
.list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.topic{padding:8px;border-radius:8px;background:#020927;display:flex;justify-content:space-between;align-items:center;border:1px solid rgba(255,255,255,0.02)}
.result-btn{min-width:44px;min-height:36px;border-radius:8px;border:0;cursor:pointer;padding:6px 10px;font-weight:800}
.result-btn.correct{background:#a855f7;color:#021018}
.result-btn.incorrect{background:#ef4444;color:white}
.result-btn.un{background:#06b6d4;color:white}
.badge{font-weight:700;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
.small{font-size:12px;color:#cfe8ff}
@media(max-width:720px){ .row{flex-direction:column} .topic{flex-direction:column;align-items:flex-start} .topic > div:last-child{align-self:flex-end} }
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h2 style="margin:0">GTA â€” Practice UI (Final)</h2>
        <div class="small">Static main timer (reduced only on successful submit). Logs show result buttons inline.</div>
      </div>
    </div>

    <div style="margin-top:12px" class="row">
      <div style="flex:1">
        <label class="small">Session Name</label>
        <input id="gta-session" class="input" placeholder="GTA_YYYY-MM-DD_001">
      </div>

      <div style="width:140px">
        <label class="small">Total Time (min)</label>
        <select id="gta-total" class="input"><option>180</option><option>120</option><option>90</option><option>60</option></select>
      </div>

      <div style="width:140px">
        <label class="small">Subject</label>
        <select id="gta-sub" class="input"><option>Mixed</option><option>Maths</option><option>Physics</option><option>Chemistry</option></select>
      </div>

      <div style="width:140px">
        <label class="small">Difficulty</label>
        <select id="gta-diff" class="input"><option>Mixed</option><option>Easy</option><option>Medium</option><option>Hard</option><option>Insane</option></select>
      </div>
    </div>

    <div style="margin-top:12px" class="row">
      <button id="gta-start" class="btn">Start GTA</button>
      <button id="gta-end" class="btn ghost">End Session</button>
      <button id="gta-export" class="btn">Export</button>
      <button id="gta-clear-session" class="btn ghost">Clear Session Logs</button>
    </div>

    <div style="margin-top:12px" class="row">
      <div style="flex:1" class="card">
        <div class="small">Main time left</div>
        <div style="font-weight:700;font-size:20px" id="main-time">03:00:00</div>
      </div>

      <div style="width:140px" class="card">
        <div class="small">Question #</div>
        <div style="font-weight:700;font-size:20px" id="q-number">â€”</div>
      </div>

      <div style="width:260px" class="card">
        <div class="small">Question timer</div>
        <div style="font-weight:700;font-size:20px" id="q-timer">00:00.0</div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="q-start" class="btn">Start</button>
          <button id="q-pause" class="btn ghost" disabled>Pause</button>
          <button id="q-resume" class="btn ghost" disabled>Resume</button>
          <button id="q-submit" class="btn" disabled>Submit</button>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h3 style="margin:0">Session Logs</h3>
        <div class="small">Logs appear immediately after Submit. Use inline buttons to mark result. Select 2 logs to Merge.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="merge" class="btn ghost" disabled>Merge Selected (2)</button>
        <button id="undo-merge" class="btn ghost" disabled>Undo Merge</button>
      </div>
    </div>

    <div id="gta-log-list" class="list small" style="margin-top:10px;max-height:520px;overflow:auto"></div>
  </div>
</div>

<footer style="color:#9fbbe8;text-align:center;padding:12px">Sunstrike â€” GTA (Final)</footer>

<!-- SheetJS for Excel export -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="utils.js"></script>
<script>
/*
  Final GTA:
  - Inline result buttons on each log (no popup)
  - Merge: Option A (recalc points from combined time)
  - XP issuance: awarded on marking Correct (if addXP exists); do not subtract XP on later changes
  - No animations; minimal styling
  - Expects utils.js with: SU.KEYS.PRACTICE, load(key,def), save(key,val), savePracticeEntry(entry), addXP(amount,tag)
    If those are missing, utils.js fallbacks should be present in your project (we kept them previously).
*/

(function(){
  // state
  let gtaRunning = false;
  let mainSeconds = 180*60;
  let qNumber = 0;

  // question timer
  let qState = 'idle'; // idle | running | paused
  let qStart = 0, qElapsed = 0, qInterval = null;

  // merge/undo
  let lastMerge = null;

  // helpers & constants
  const el = id => document.getElementById(id);
  const PRACT = (window.SU && window.SU.KEYS && window.SU.KEYS.PRACTICE) ? window.SU.KEYS.PRACTICE : 'SU_PRACTICE_LOGS';

  function fmtMS(ms){
    const s = Math.floor(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    const t = Math.floor(ms%1000/100);
    return `${mm}:${ss}.${t}`;
  }
  function fmtMain(sec){
    if(sec < 0) sec = 0;
    const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = Math.floor(sec%60);
    return [String(h).padStart(2,'0'), String(m).padStart(2,'0'), String(s).padStart(2,'0')].join(':');
  }

  function calcPoints(timeSec, diff){
    const base = diff==='Easy'?8:diff==='Medium'?15:diff==='Hard'?40:diff==='Insane'?80:10;
    const pts = Math.max(0, Math.round(base - Math.floor(timeSec/4)));
    return Math.max(1, pts);
  }

  // UI renderers
  function renderHeader(){
    el('main-time').textContent = fmtMain(mainSeconds);
    el('q-number').textContent = qNumber > 0 ? qNumber : 'â€”';
    el('q-start').disabled = !gtaRunning || qState === 'running';
    el('q-pause').disabled = qState !== 'running';
    el('q-resume').disabled = qState !== 'paused';
    el('q-submit').disabled = qState !== 'running';
  }

  function renderLogs(){
    const sessionName = el('gta-session').value || localStorage.getItem('su_default_gta') || '';
    const root = el('gta-log-list');
    root.innerHTML = '';
    if(!sessionName){ root.innerHTML = '<div class="small">Set a session name and start.</div>'; disableMerge(); return; }
    const sessionKey = 'GTA:' + sessionName;
    const all = (load(PRACT, []) || []).filter(x => x.session === sessionKey).sort((a,b)=> (a.t||0)-(b.t||0));
    if(all.length === 0){ root.innerHTML = '<div class="small">No logs yet for this session.</div>'; disableMerge(); return; }

    all.forEach((log, idx) => {
      const wrap = document.createElement('div'); wrap.className = 'topic';
      const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
      const cb = document.createElement('input'); cb.type='checkbox'; cb.className='merge-cb'; cb.dataset.t = log.t;
      cb.style.marginRight = '8px';
      left.appendChild(cb);
      const info = document.createElement('div');
      info.innerHTML = `<strong>Q${log.q || (idx+1)} â€¢ ${log.subject}</strong><div class="small">${log.diff} â€¢ ${log.time}s â€¢ ${new Date(log.t).toLocaleString()}</div>`;
      left.appendChild(info);

      const right = document.createElement('div'); right.style.display='flex'; right.style.flexDirection='column'; right.style.alignItems='flex-end';
      const btnRow = document.createElement('div'); btnRow.style.display='flex'; btnRow.style.gap='8px';

      // inline result buttons
      const bCorrect = document.createElement('button'); bCorrect.className='result-btn correct'; bCorrect.textContent='ðŸŸ©';
      const bIncorrect = document.createElement('button'); bIncorrect.className='result-btn incorrect'; bIncorrect.textContent='âŒ';
      const bUn = document.createElement('button'); bUn.className='result-btn un'; bUn.textContent='â—¯';

      // points badge
      const badge = document.createElement('div'); badge.className='badge';
      badge.textContent = `${log.points} pts${log.awarded? ' âœ“' : ''}`;

      function refreshButtons(){
        bCorrect.style.opacity = log.result==='Correct' ? '1' : '0.6';
        bIncorrect.style.opacity = log.result==='Incorrect' ? '1' : '0.6';
        bUn.style.opacity = (log.result==='Unattempted' || log.result==='Pending') ? '1' : '0.6';
        badge.textContent = `${log.points} pts${log.awarded? ' âœ“' : ''}`;
      }
      refreshButtons();

      bCorrect.addEventListener('click', ()=> markResultInline(log.t, 'Correct'));
      bIncorrect.addEventListener('click', ()=> markResultInline(log.t, 'Incorrect'));
      bUn.addEventListener('click', ()=> markResultInline(log.t, 'Unattempted'));

      btnRow.appendChild(bCorrect); btnRow.appendChild(bIncorrect); btnRow.appendChild(bUn); btnRow.appendChild(badge);

      const del = document.createElement('button'); del.className='btn ghost'; del.textContent='Delete';
      del.onclick = ()=> { if(!confirm('Delete this log?')) return; let arr = load(PRACT, []) || []; arr = arr.filter(x => x.t !== log.t); save(PRACT, arr); renderLogs(); };

      right.appendChild(btnRow);
      right.appendChild(del);

      const container = document.createElement('div'); container.style.display='flex'; container.style.justifyContent='space-between'; container.style.alignItems='center';
      container.appendChild(left); container.appendChild(right);
      wrap.appendChild(container);
      root.appendChild(wrap);
    });

    document.querySelectorAll('.merge-cb').forEach(cb => cb.addEventListener('change', onMergeSelectionChange));
    updateMergeButtons();
    root.scrollTop = root.scrollHeight;
  }

  function disableMerge(){ el('merge').disabled = true; el('undo-merge').disabled = !lastMerge; }
  function updateMergeButtons(){ const checks = Array.from(document.querySelectorAll('.merge-cb') || []).filter(c=> c.checked); el('merge').disabled = checks.length !== 2; el('undo-merge').disabled = !lastMerge; }
  function onMergeSelectionChange(){ updateMergeButtons(); }

  // mark result inline (awards XP only on Correct; does not subtract on later changes)
  function markResultInline(ts, choice){
    const arr = load(PRACT, []) || [];
    const i = arr.findIndex(x => x.t === ts);
    if(i === -1) return;
    const entry = arr[i];
    entry.result = choice;
    // If marking Incorrect, set points to 0 (you asked this behavior previously). If you prefer keeping points but not awarding, tell me.
    if(choice === 'Incorrect'){ entry.points = 0; }
    // Award XP only when mark Correct and not already awarded
    if(choice === 'Correct' && !entry.awarded){
      try{ addXP(entry.points, 'gta'); }catch(e){ console.warn('addXP missing', e); }
      entry.awarded = true;
    }
    arr[i] = entry;
    save(PRACT, arr);
    renderLogs();
  }

  // question controls
  function qStart(){
    if(!gtaRunning){ alert('Start GTA session first'); return; }
    if(qState === 'running') return;
    qNumber += 1;
    qStart = Date.now() - qElapsed;
    qInterval = setInterval(()=> {
      qElapsed = Date.now() - qStart;
      el('q-timer').textContent = fmtMS(qElapsed);
    }, 100);
    qState = 'running';
    renderHeader();
  }
  function qPause(){
    if(qState !== 'running') return;
    clearInterval(qInterval); qInterval = null;
    qState = 'paused';
    renderHeader();
  }
  function qResume(){
    if(qState !== 'paused') return;
    qStart = Date.now() - qElapsed;
    qInterval = setInterval(()=> {
      qElapsed = Date.now() - qStart;
      el('q-timer').textContent = fmtMS(qElapsed);
    }, 100);
    qState = 'running';
    renderHeader();
  }
  function qResetAfterSubmit(){
    if(qInterval) clearInterval(qInterval);
    qInterval = null;
    qElapsed = 0;
    qState = 'idle';
    el('q-timer').textContent = '00:00.0';
    renderHeader();
  }

  // save entry helper â€” prevents duplicates by timestamp
  function saveEntry(entry){
    const arr = load(PRACT, []) || [];
    if(arr.some(x => x.t === entry.t)) return false;
    arr.push(entry);
    save(PRACT, arr);
    return true;
  }

  // submit: saves pending log, reduces mainSeconds, no popup, inline buttons in log let you mark later
  function qSubmit(){
    if(qState === 'paused'){ alert('Resume before submitting.'); return; }
    if(qState !== 'running'){ alert('Start the question before submitting.'); return; }
    // stop q timer
    if(qInterval) { clearInterval(qInterval); qInterval = null; }
    const timeSec = Math.round((qElapsed||0)/1000);
    if(timeSec > mainSeconds){
      alert('Time exceeded remaining main time â€” submission rejected. Session continues.');
      qResetAfterSubmit();
      return;
    }
    const name = el('gta-session').value || localStorage.getItem('su_default_gta') || ('GTA_'+new Date().toISOString().slice(0,10)+'_'+Math.floor(Math.random()*1000));
    el('gta-session').value = name;
    localStorage.setItem('su_default_gta', name);
    const sessionKey = 'GTA:' + name;
    const sub = el('gta-sub').value || 'Mixed';
    const diff = el('gta-diff').value || 'Mixed';
    const pts = calcPoints(timeSec, diff);
    const entry = { session: sessionKey, subject: sub, diff, time: timeSec, points: pts, result: 'Pending', awarded: false, q: qNumber, t: Date.now() };
    const ok = saveEntry(entry);
    if(!ok){
      alert('Duplicate prevented (try again).');
      qResetAfterSubmit();
      return;
    }
    // deduct main time only on successful save
    mainSeconds -= timeSec; if(mainSeconds < 0) mainSeconds = 0;
    renderHeader();
    renderLogs();
    qResetAfterSubmit();
  }

  // merge exactly 2 logs (Option A: recalc points from combined time)
  function mergeHandler(){
    const checks = Array.from(document.querySelectorAll('.merge-cb') || []).filter(c=> c.checked);
    if(checks.length !== 2) return alert('Select exactly 2 logs to merge.');
    const t1 = Number(checks[0].dataset.t), t2 = Number(checks[1].dataset.t);
    const arr = load(PRACT, []) || [];
    const l1 = arr.find(x=> x.t === t1), l2 = arr.find(x=> x.t === t2);
    if(!l1 || !l2) return alert('Selected logs not found.');
    if(l1.session !== l2.session){
      if(!confirm('Selected logs are from different sessions. Merge anyway?')) return;
    }
    const combinedTime = (Number(l1.time)||0) + (Number(l2.time)||0);
    const newDiff = l2.diff || l1.diff || 'Mixed';
    const newQ = Math.min(l1.q||9999, l2.q||9999);
    const newPoints = calcPoints(Math.round(combinedTime), newDiff);
    const newEntry = { session: l1.session, subject: l2.subject||l1.subject, diff: newDiff, time: Math.round(combinedTime), points: newPoints, result: l2.result || 'Pending', awarded: false, q: newQ, t: Date.now() };

    // remove old and add merged
    const remaining = arr.filter(x => x.t !== t1 && x.t !== t2);
    lastMerge = { removed: [l1, l2], added: newEntry };
    remaining.push(newEntry);
    save(PRACT, remaining);

    // XP handling: if you want to give delta positive XP, do it; currently we do NOT auto-adjust XP to keep safe.
    // If you'd like delta XP reward, uncomment addXP below:
    // const oldSum = (Number(l1.points)||0) + (Number(l2.points)||0);
    // const delta = newPoints - oldSum; if(delta > 0) addXP(delta, 'merge');

    alert(`Merged logs â†’ ${newEntry.time}s â€¢ result=${newEntry.result} â€¢ points=${newEntry.points}`);
    renderLogs();
    updateMergeButtons();
  }

  function undoMerge(){
    if(!lastMerge) return alert('No merge to undo.');
    const arr = load(PRACT, []) || [];
    const remaining = arr.filter(x => x.t !== lastMerge.added.t);
    remaining.push(...lastMerge.removed);
    save(PRACT, remaining);
    lastMerge = null;
    alert('Undo merge performed.');
    renderLogs();
    updateMergeButtons();
  }

  // export session logs to Excel (no duplicate rows)
  function exportHandler(){
    const name = el('gta-session').value || localStorage.getItem('su_default_gta') || '';
    if(!name) return alert('Set session name first.');
    const session = 'GTA:'+name;
    const all = (load(PRACT, []) || []).filter(x=> x.session === session);
    if(!all.length) return alert('No logs to export.');
    const seen = {}; const unique = [];
    all.forEach(r => { if(!seen[r.t]){ seen[r.t]=true; unique.push(r); }});
    const ws = [['Date','Session','Q#','Subject','Difficulty','Time(s)','Result','Points','Awarded']];
    unique.forEach(r => ws.push([ new Date(r.t).toLocaleString(), r.session, r.q||'', r.subject, r.diff, r.time, r.result, r.points, r.awarded? 'Yes':'No' ]));
    const wb = XLSX.utils.book_new(); const ws1 = XLSX.utils.aoa_to_sheet(ws);
    XLSX.utils.book_append_sheet(wb, ws1, 'GTA'); XLSX.writeFile(wb, 'Sunstrike_GTA_'+name+'.xlsx');
  }

  function clearSession(){
    const name = el('gta-session').value || localStorage.getItem('su_default_gta') || '';
    if(!name) return alert('No session name set');
    if(!confirm('Clear ALL logs for this session?')) return;
    let arr = load(PRACT, []) || [];
    arr = arr.filter(x => x.session !== ('GTA:'+name));
    save(PRACT, arr);
    renderLogs();
  }

  // wiring
  el('q-start').addEventListener('click', qStart);
  el('q-pause').addEventListener('click', qPause);
  el('q-resume').addEventListener('click', qResume);
  el('q-submit').addEventListener('click', qSubmit);

  el('gta-start').addEventListener('click', ()=>{
    if(gtaRunning) return alert('GTA already running');
    const tn = Number(el('gta-total').value || 180);
    mainSeconds = tn * 60;
    el('main-time').textContent = fmtMain(mainSeconds);
    el('gta-session').value = el('gta-session').value || ('GTA_'+new Date().toISOString().slice(0,10)+'_'+Math.floor(Math.random()*1000));
    localStorage.setItem('su_default_gta', el('gta-session').value);
    gtaRunning = true;
    qNumber = 0; qElapsed = 0; qState = 'idle';
    renderHeader(); renderLogs();
    alert('GTA started â€” main timer is static and reduced only when you submit questions.');
  });

  el('gta-end').addEventListener('click', ()=>{ if(!gtaRunning) return; if(!confirm('End GTA session now?')) return; gtaRunning = false; renderHeader(); });

  el('merge').addEventListener('click', mergeHandler);
  el('undo-merge').addEventListener('click', undoMerge);
  el('gta-export').addEventListener('click', exportHandler);
  el('gta-clear-session').addEventListener('click', clearSession);

  window.addEventListener('storage', (e)=>{ if(e.key === PRACT) renderLogs(); });

  // init
  renderHeader(); renderLogs();

  // expose debug helper
  window._GTA_final = { renderHeader, renderLogs, PRACT, version:'final-inline-results' };

})();
</script>
</body>
</html>